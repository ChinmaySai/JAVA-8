Stream is an interface provided as a part of java.util.stream package.

Stream will not disturb the actual source objects.

 Stream -----> Channel through which there is a free flow movement of data.
 Streams
 To process objects of the collection, in 1.8 version Streams concept introduced.
 
What is the difference between collection and stream?
 => If we want to represent a group of individual objects as a single entity then 
We should go for collection.
 => If we want to process a group of objects from the collection then we should go for streams.

Stream Initilazation :

package com.stream.creation;

import java.util.*;
import java.util.stream.*;

public class StreamCreation {

	public static void main(String[] args) {
		
		//From Collection Object
		List<String> values=List.of("One","Two","Three");
		Stream<String> stream1=values.stream(); 
		
		//Creation from Array of Values
		String names[]= {"One","Two","Third"};
		Stream<String> stream2=Arrays.stream(names);
		stream2.forEach(System.out::println);
		
		//Stream.Of() static  Method 
		Stream<String> stream3=Stream.of("One","Two","Third");
		
          //Creating an Empty Stream
		Stream<String> stream4=Stream.empty();
	}

}

Stream Operations:
Intermediate Operations
Terminal Operations

Stream Pipeline:

In Java 8, the Stream API introduced a powerful way to process collections of data using a stream pipeline. A stream pipeline consists of three main components:

Source: The data source (e.g., a collection, array, or I/O channel) that provides the elements to the stream.
Intermediate Operations: Transformations applied to the stream, such as filtering, mapping, or sorting. These operations are lazy and do not execute until a terminal operation is invoked.
Terminal Operation: The final operation that triggers the processing of the stream, such as collecting results, reducing, or iterating.

When we call any of the intermediate operation it will always return a Stream of Objects.on Single Stream we can call any number of intermediate methods.

Intermediate operations will be executed only when we invoke terminal operation.

Terminal Operation:
We can call have only one terminal operation on the stream instance.
Once the terminal Operation is called we will get the result of the all the pipelined operations on the stream object.

Map:
package com.stream.operations;
import java.util.*;
import java.util.stream.*;

public class StreamOperations {
	
	public static void main(String[] args) {
		
		List<Employee> employees=getEmployee();
		List<String> empNames=new ArrayList<String>();
		//Prior to Java 8
		for(Employee emp:employees)
		{
			empNames.add(emp.getName());
		}
		empNames.forEach(n->System.out.println(n));
		
		//In Java8
		Stream<Employee> streamEmployee=employees.stream();
		List<String> empString=streamEmployee.map(emp->emp.getName()).collect(Collectors.toList());
		System.out.println(empString);
		
		
	}
	
	public static List<Employee> getEmployee()
	{
		//int id, String name, String city, int age, String gender, String department, int yearofJoining,
		//double salary
		List<Employee> employeeList=new ArrayList<>();
		employeeList.add(new Employee(101, "Alice Johnson", "New York", 28, "Female", "HR", 2019, 60000));
        employeeList.add(new Employee(102, "Bob Smith", "San Francisco", 32, "Male", "Engineering", 2017, 95000));
        employeeList.add(new Employee(103, "Carol Danvers", "Los Angeles", 30, "Female", "Marketing", 2020, 72000));
        employeeList.add(new Employee(104, "David Lee", "Chicago", 35, "Male", "Finance", 2015, 85000));
        employeeList.add(new Employee(105, "Eva Green", "Seattle", 26, "Female", "Engineering", 2021, 68000));
        employeeList.add(new Employee(106, "Frank Turner", "Boston", 29, "Male", "Sales", 2018, 62000));
        employeeList.add(new Employee(107, "Grace Kim", "Austin", 31, "Female", "HR", 2016, 59000));
        employeeList.add(new Employee(108, "Henry Walker", "Denver", 33, "Male", "IT", 2014, 98000));
        employeeList.add(new Employee(109, "Isabel Torres", "Atlanta", 27, "Female", "Support", 2022, 50000));
        employeeList.add(new Employee(110, "Jack Reed", "Miami", 36, "Male", "Legal", 2013, 88000));

		return employeeList;
	
	}

}

Once a Stream Object is created we can process through Stream pipeline  only one time .


map -- Functional interface
filter -- Predicate interface
forEach - Consumer interface
anyMatch()-- Takes the Predicate interface -- Even if one of the stream Object matches it returns true.
allMatch() -- Will be true only when all the Stream Objects matches.

findAny() -- Returns an Optional describing some element of this stream, or anempty Optional if the stream is empty
//findAny()
	     //get any One value from out of All Values
	     Employee emp=employees.stream().findAny()
	    		 .get(); //On Optional we can apply get method 
	     System.out.println(emp);

//findFirst()
	     //It always returns the First element of the Stream
	    Employee emp1=employees.stream().findFirst().get();
	    System.out.println(emp1);
	
//sorted() -- Sorts the Elements in Ascending Order
	    //Get the Employees id's in sorted order
	   List<Integer> sortedEmpids= employees.stream().map(emp2->emp2.getId()).sorted().collect(Collectors.toList());
	   System.out.println("Sorted Empid's "+sortedEmpids);
	   
//Minimum Salary Employee Details
         Employee empint= employees.stream().min((i1,i2) -> {return (int) (i1.getSalary()-i2.getSalary());}).get();	 
         System.out.println("Minimum salaried Employee"+empint);
 
mapToDouble returns DoubleStream -- DoubleStream contains only Double Values
mapToInt returns IntStream
mapToLong returns LongStream 

average() will always return Optional Double

//peek() -- Takes Consumer Function as an Input -- Takes the input but doesn't return any value
peek can be mainly used to know what is the current status/trace of stream like what Objects will be passed to next Operation in the Stream Pipeline

//peek()
         System.out.println("**********Peek Method**********");
         List<Employee> employeest=employees.stream().filter(emp5-> emp5.getYearofJoining()>2015).peek(System.out::println).collect(Collectors.toList());
         
         System.out.println("\n"+employeest); 
		 
		 
When an stream() method is called it will create sequential from the Objects.
	
When an parallelStream() method is called it will create sequential from the Objects.
when we create a stream with parallelStream internally stream will be divided into multiple sections.
Internally the stream will be divided into multiple sections and operations will be performed on each of the sections simultaneoulsy buy mutiple Threads.
parallelStream doesn't guarntee the order of elements but the processing will be faster when compared with the normal stream

Collectors class is introduced as part of Java 8.Contains several utility methods using which we can perform several operations of the stream
